# Ответы на теоретические вопросы

## 1. Event Propagation (Распространение событий)

### Описание процесса
Event Propagation в JavaScript — это механизм, который определяет, как события "путешествуют" по DOM-дереву. Когда на элементе происходит событие (например, клик), оно не ограничивается только этим элементом. Этот процесс состоит из трёх фаз:

1.  **Фаза погружения (Capturing Phase):** Событие "спускается" от самого верхнего элемента (`window`), через `document`, `<html>`, `<body>` и так далее, до родительского элемента цели. На этой фазе обработчики, зарегистрированные с опцией `{ capture: true }`, могут перехватить событие.

2.  **Фаза цели (Target Phase):** Событие достигает элемента, на котором оно непосредственно произошло (целевого элемента). На этой фазе срабатывают обработчики, навешанные на сам этот элемент.

3.  **Фаза всплытия (Bubbling Phase):** Событие начинает "подниматься" от целевого элемента обратно вверх к `window`. Это фаза по умолчанию, и большинство обработчиков событий срабатывают именно на ней. Например, клик на кнопке сначала вызовет обработчик на самой кнопке, затем на её родителе, затем на родителе родителя и так далее до `window`.

### Практическое применение

-   **Делегирование событий:** Это самый частый и полезный способ применения. Вместо того чтобы вешать по одному обработчику на 100 кнопок в списке, можно повесить один обработчик на их общего родителя (`<ul>`). Благодаря всплытию, клик по любой кнопке (`<li>`) "поднимется" до `<ul>`, где его можно будет поймать. В обработчике через `event.target` можно определить, на каком именно дочернем элементе произошел клик. Это экономит память и упрощает код, особенно для динамически добавляемых элементов.

-   **Остановка распространения (`event.stopPropagation()`):** Иногда нужно, чтобы событие не "всплывало" дальше. Например, у вас есть модальное окно с кнопкой "Закрыть". Клик на оверлей (фон) должен закрывать окно, но клик на контент внутри окна — нет. Если не остановить всплытие от контента, клик "поднимется" до оверлея и закроет окно. Вызвав `event.stopPropagation()` на контейнере с контентом, мы предотвратим это.

-   **Перехват на фазе погружения:** Это редкий случай, но он может быть полезен для логирования, аналитики или для того, чтобы гарантированно перехватить событие до того, как его остановит какой-либо дочерний элемент с помощью `stopPropagation()`.

## 2. Promise и асинхронность в JavaScript

### Что такое Promise?
`Promise` (обещание) — это специальный объект в JavaScript, который представляет собой результат асинхронной операции, который может быть еще не известен. Он позволяет писать асинхронный код в более удобном и читаемом виде, избегая "ада колбэков" (callback hell).

### Как он работает и какие у него состояния?
`Promise` может находиться в одном из трёх состояний:
1.  **`pending` (ожидание):** Начальное состояние. Операция еще не завершена.
2.  **`fulfilled` (выполнено успешно):** Операция завершилась успешно, и `Promise` вернул результат (значение).
3.  **`rejected` (отклонено):** Операция завершилась с ошибкой, и `Promise` вернул причину ошибки.

`Promise` является "одноразовым" — из состояния `pending` он может перейти либо в `fulfilled`, либо в `rejected`, но не обратно.

### Способы обработки асинхронного кода
1.  **`.then()`, `.catch()`, `.finally()`:**
  -   `.then(onFulfilled, onRejected)`: Позволяет подписаться на результат. Первый аргумент — функция, которая выполнится при успешном завершении. Второй (необязательный) — при ошибке.
  -   `.catch(onRejected)`: Более удобный способ обработки ошибок, чем второй аргумент в `.then()`.
  -   `.finally(onFinally)`: Выполняется в любом случае после завершения `Promise`, независимо от того, был он успешным или нет. Удобно для очистки ресурсов (например, скрытия индикатора загрузки).

2.  **`async/await`:**
  -   Это синтаксический сахар над `Promise`, который позволяет писать асинхронный код так, как будто он синхронный.
  -   Ключевое слово `async` перед функцией означает, что она всегда возвращает `Promise`.
  -   Ключевое слово `await` можно использовать только внутри `async`-функции. Оно "ставит на паузу" выполнение функции до тех пор, пока `Promise` не будет выполнен, и возвращает его результат.
  -   Для обработки ошибок используется стандартная конструкция `try...catch`.

### Роль Event Loop (Событийный цикл)
Event Loop — это сердце асинхронности в JavaScript. JS сам по себе однопоточный, то есть в один момент времени он может выполнять только одну задачу.
-   Когда JS встречает асинхронную операцию (например, `fetch`, `setTimeout`), он не ждет ее завершения. Он передает эту операцию в Web API (среда браузера).
-   Сам JS продолжает выполнять синхронный код дальше в **Call Stack**.
-   Когда Web API завершает операцию, он помещает callback-функцию (например, то, что внутри `.then()`) в **Callback Queue** (очередь обратных вызовов).
-   **Event Loop** постоянно проверяет, пуст ли **Call Stack**. Как только он становится пустым, Event Loop берет первую задачу из **Callback Queue** и перемещает ее в **Call Stack** для выполнения.

Таким образом, Event Loop обеспечивает неблокирующее выполнение кода, позволяя JS оставаться "отзывчивым" во время ожидания долгих операций.

## 3. Объектно-ориентированное программирование (ООП)

### Что такое ООП?
ООП — это парадигма программирования, основанная на представлении программы в виде совокупности взаимодействующих объектов. Каждый объект является экземпляром определенного класса и может иметь свои свойства (данные) и методы (поведение).

### Ключевые принципы ООП
1.  **Инкапсуляция:**
  -   **Описание:** Сокрытие внутренней реализации объекта и предоставление наружу только публичного интерфейса (методов) для взаимодействия с ним. Данные объекта защищены от прямого неконтролируемого доступа.
  -   **Пример:** Объект "Кофемашина". Мы не знаем, как она внутри греет воду и мелет зерна. Мы просто нажимаем кнопку "Сделать эспрессо" (`makeEspresso()`). Все сложные процессы инкапсулированы внутри.

2.  **Наследование:**
  -   **Описание:** Механизм, позволяющий создавать новый класс (потомок) на основе существующего (родитель), заимствуя его свойства и методы. Потомок может расширять или переопределять поведение родителя.
  -   **Пример:** Есть базовый класс `Транспорт` с методом `двигаться()`. Класс `Автомобиль` наследуется от `Транспорта`, получает метод `двигаться()` и добавляет свой собственный — `включитьФары()`.

3.  **Полиморфизм:**
  -   **Описание:** Способность объектов с одним и тем же интерфейсом (например, с одинаковым названием метода) иметь разную реализацию этого интерфейса.
  -   **Пример:** Есть разные классы: `Собака`, `Кошка`, `Птица`. У всех есть метод `издатьЗвук()`. При вызове этого метода для объекта `Собака` мы услышим "гав", а для `Кошка` — "мяу". Код, который вызывает этот метод, может не знать, с каким именно животным он работает, но получит правильное поведение.

4.  **Абстракция:**
  -   **Описание:** Выделение наиболее значимых характеристик объекта и отбрасывание несущественных. Мы создаем упрощенную модель реального объекта, которая содержит только то, что важно для нашей программы.
  -   **Пример:** Моделируя объект "Пользователь" для сайта, нам важны его `логин`, `пароль`, `email`, но совершенно не важны `цвет глаз` или `рост`. Мы абстрагируемся от лишних деталей.

### ООП в JavaScript
JavaScript — это прототипно-ориентированный язык, но он поддерживает ООП-принципы.
-   **До ES6 (2015):** ООП реализовывалось через функции-конструкторы и манипуляции с `prototype`. `new User()` создавал объект, а методы добавлялись в `User.prototype`. Наследование было сложным и реализовывалось через цепочки прототипов.
-   **После ES6:** Появился синтаксический сахар — классы (`class`), которые делают код более похожим на классические ООП-языки (Java, C++).
  -   `class User { constructor(name) { this.name = name; } sayHi() { console.log(this.name); } }`
  -   Наследование реализуется через ключевое слово `extends`.
  -   Инкапсуляция поддерживается через приватные поля и методы (с префиксом `#`, например, `#privateField`).

Под капотом `class` в JS все еще использует прототипы, но синтаксис стал намного чище и понятнее.

## 4. Обработка URL в браузере

### Детальное описание процесса
1.  **Ввод URL и парсинг:** Пользователь вводит `https://example.com/path` и нажимает Enter. Браузер парсит URL, выделяя протокол (`https`), домен (`example.com`), путь (`/path`).

2.  **Проверка кеша (HSTS):** Браузер проверяет, есть ли домен `example.com` в списке HSTS (HTTP Strict Transport Security). Если да, то все запросы к нему будут принудительно идти по `https`.

3.  **DNS-запрос:**
  -   Браузер ищет IP-адрес для домена `example.com` в своем кеше.
  -   Если не нашел, проверяет кеш операционной системы (файл `hosts`).
  -   Если и там нет, отправляет запрос к DNS-резолверу (обычно провайдера).
  -   DNS-резолвер рекурсивно ищет IP-адрес у корневых, доменных и авторитативных DNS-серверов.
  -   В итоге браузер получает IP-адрес сервера, например, `93.184.216.34`.

4.  **Установление TCP-соединения:** Браузер устанавливает TCP-соединение с сервером по полученному IP-адресу (обычно на порт 443 для HTTPS). Происходит "тройное рукопожатие" (SYN, SYN-ACK, ACK).

5.  **TLS-рукопожатие (для HTTPS):**
  -   Браузер и сервер обмениваются сообщениями для аутентификации друг друга (сервер предоставляет свой SSL-сертификат).
  -   Они договариваются о шифре и генерируют сессионные ключи.
  -   С этого момента все данные между ними шифруются.

6.  **Отправка HTTP-запроса:** Браузер формирует и отправляет HTTP-запрос. Он включает:
  -   **Стартовая строка:** `GET /path HTTP/1.1`
  -   **Заголовки (Headers):** `Host: example.com`, `User-Agent`, `Accept`, `Cookie` и др.
  -   **Тело запроса (Body):** Для GET-запроса обычно пустое.

7.  **Ожидание ответа от сервера:** Сервер обрабатывает запрос (находит нужный файл или запускает скрипт) и отправляет HTTP-ответ.

8.  **Получение и обработка ответа:** Браузер получает ответ, который состоит из:
  -   **Стартовая строка:** `HTTP/1.1 200 OK`
  -   **Заголовки:** `Content-Type: text/html`, `Content-Length`, `Set-Cookie` и др.
  -   **Тело ответа:** HTML-код страницы.

9.  **Рендеринг страницы:**
  -   **Парсинг HTML:** Браузер начинает парсить HTML и строить **DOM-дерево**.
  -   **Запрос ресурсов:** Встречая теги `<link>`, `<script>`, `<img>`, браузер отправляет новые HTTP-запросы для загрузки CSS, JS, изображений (многие из них параллельно).
  -   **Построение CSSOM:** CSS-файлы парсятся, и на их основе строится **CSSOM-дерево** (объектная модель CSS).
  -   **Создание Render Tree:** На основе DOM и CSSOM создается **Render Tree**, которое содержит только видимые узлы и их стили.
  -   **Layout (Reflow):** Браузер вычисляет точные размеры и положение каждого элемента на странице.
  -   **Painting ( отрисовка):** Браузер "рисует" пиксели на экране.

10. **Выполнение JavaScript:** JS-код может изменять DOM и CSSOM, что может запустить повторные циклы Layout и Painting (это называется **Reflow** и **Repaint**), поэтому его загрузку и выполнение часто оптимизируют.

### Технологии ускорения
-   **Кеширование:** Браузер кеширует статические ресурсы (CSS, JS, картинки). При повторном посещении они берутся с диска, а не из сети.
-   **CDN (Content Delivery Network):** Ресурсы хранятся на серверах по всему миру. Пользователь получает их с географически ближайшего сервера.
-   **HTTP/2 и HTTP/3:** Позволяют загружать множество ресурсов через одно TCP-соединение (мультиплексирование), что гораздо быстрее.
-   **Сжатие:** Gzip/Brotli для сжатия текста (HTML, CSS, JS). WebP/AVIF для сжатия изображений.
-   **Асинхронная загрузка JS:** Атрибуты `async` и `defer` у тега `<script>` позволяют не блокировать рендеринг страницы во время загрузки скриптов.

### Проблемы (безопасность, взаимодействие)
-   **CORS (Cross-Origin Resource Sharing):** По умолчанию браузер запрещает скриптам с одного домена (`origin`) делать запросы к другому. Чтобы разрешить это, сервер-получатель должен отправить специальный заголовок `Access-Control-Allow-Origin`.
-   **CSP (Content Security Policy):** Механизм защиты от XSS-атак. Сервер указывает браузеру, с каких доменов можно загружать и выполнять ресурсы (скрипты, стили).
-   **XSS (Cross-Site Scripting):** Атака, при которой злоумышленник внедряет свой вредоносный скрипт на страницу, который выполняется в браузере пользователя.
-   **CSRF (Cross-Site Request Forgery):** Атака, заставляющая браузер пользователя выполнить нежелательное действие на сайте, где он уже авторизован (например, перевести деньги).
